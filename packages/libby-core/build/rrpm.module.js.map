{"version":3,"file":"rrpm.module.js","sources":["../src/DAOCommand.js","../src/StoreStrategy.js","../src/DAOQueryBuilder.js","../src/DAO.js","../src/Database.js","../src/DatabaseConnector.js","../src/memory/MemoryDAO.js","../src/memory/MemoryStoreStrategy.js","../src/session/storage/SessionStore.js","../src/user/mapper/Mapper.js","../src/user/RoleDTO.js","../src/user/mapper/RoleMapper.js","../src/user/UserDTO.js","../src/user/mapper/UserMapper.js","../src/SessionStrategy.js","../src/Libby.js"],"sourcesContent":["export class DAOCommand {\n\n    constructor(parameter,operation={save:false,remove:false},target,name) {\n        this.parameter = parameter;\n        this.operation = operation;\n        this.target = target;\n        this.name = name;\n        this.error = null;\n        this.data=[];\n    }\n\n    done(data) {\n        if (this.isResultset()) {\n            this.data = data;\n            this.target.propagateDAO(this.name,data);\n        } else {\n            this.target.forceUpdate();\n        }\n    }\n\n    failed(e) {\n        this.error = e;\n        this.target.forceUpdate();\n    }\n\n    commandHasStarted() {\n        this.target.stateHasChanged();\n    }\n\n    isResultset() {\n        return !this.operation.save && !this.operation.remove;\n    }\n\n    isSave() {\n        return this.operation.save;\n    }\n\n    isRemove() {\n        return this.operation.remove;\n    }\n\n}","\nimport _ from \"lodash\";\nexport class StoreStrategy {\n\n    constructor(name,pk) {\n        this.name = name;\n        this.pk = pk;\n        this.listeners = [];\n    }\n\n    addStoreListener(listener) {\n        this.listeners.push(listener);\n    }\n\n    removeStoreListener(listener) {\n        _.pull(this.listeners, listener);\n    }\n\n    notify() {\n        this.listeners.forEach((listener)=>{\n            listener.storeHasChanged(this.name);\n        });\n    }\n    \n}","class Aggregate {\n\n    constructor(getQuery) {\n        this.selected = false;\n        const fields = {};\n        const aggregations = [];\n        const groups = {};\n        this.getQuery = getQuery;\n        this.config = { fields, aggregations, groups };\n    }\n\n    toURL() {\n        const fields = (this.config.fields);\n        const functions = (this.config.aggregations);\n        const groupbys = (this.config.groups);\n        const parameters = [];\n        if (isArray(fields)) {\n            fields.forEach((field) => {\n                parameters.push(`aggregate.field[${field}]=${field}`);\n            });\n        }\n        functions.forEach((fn) => {\n            parameters.push(`aggregate.function[${fn.field}]=${fn.operator}`);\n        });\n        if (isArray(groupbys)) {\n            groupbys.forEach((group) => {\n                parameters.push(`aggregate.group[${group}]=${group}`);\n            });\n        }\n        parameters.push('aggregated=true');\n        return parameters;\n    }\n\n    count(field, as = `countof${field}`) {\n        const operator = Aggregate.Operator.COUNT;\n        this.config.aggregations.push({ operator, field, as });\n        return this;\n    }\n\n    sum(field, as = `sumof${field}`) {\n        const operator = Aggregate.Operator.SUM;\n        this.config.aggregations.push({ operator, field, as });\n        return this;\n    }\n\n    avg(field, as = `avgof${field}`) {\n        const operator = Aggregate.Operator.AVG;\n        this.config.aggregations.push({ operator, field, as });\n        return this;\n    }\n\n    min(field, as = `mninof${field}`) {\n        const operator = Aggregate.Operator.MIN;\n        this.config.aggregations.push({ operator, field, as });\n        return this;\n    }\n\n    max(field, as = `maxof${field}`) {\n        const operator = Aggregate.Operator.MAX;\n        this.config.aggregations.push({ operator, field, as });\n        return this;\n    }\n\n    groupBy(...fields) {\n        this.config.groups = fields;\n        this.config.fields = fields;\n        return this;\n    }\n\n    async run() {\n        const target = this.getQuery();\n        return target.run.bind(target)();\n    }\n\n\n\n}\n\nAggregate.Operator = {\n    SUM: 'sum',\n    AVG: 'avg',\n    MAX: 'max',\n    MIN: 'min',\n    COUNT: 'count'\n};\n\n\n\n\nexport class DAOQueryBuilder {\n\n    constructor(dao) {\n        this.dao = dao;\n        this.aggregated = false;\n        this._aggregate = new Aggregate(() => this);\n        const filter = {};\n        const order = [];\n        const limit = { from: 0, to: 0 };\n        this._config = { filter, order, limit };\n        this.groupActive = 0;\n        this.group = 0;\n    }\n\n    get config() {\n        return this._config;\n    }\n\n\n    aggregate() {\n        if (this._aggregated) throw new Error(\"You can't aggregate multiple times\");\n        this._aggregated = true;\n        this._config.aggregate = this._aggregate;\n        return this._aggregate;\n    }\n\n\n\n    between(field, value, to, alias = field) {\n        const type = DAOQueryBuilder.RANGE;\n        this._config.filter[Symbol(alias)] = { field, value, to, type };\n        return this;\n    }\n\n    equals(field, value, alias = field) {\n        const type = DAOQueryBuilder.EQUALS;\n        this._config.filter[Symbol(alias)] = { field, value, type };\n        return this;\n    }\n\n    notEquals(field,value, alias=field) {\n        const type = DAOQueryBuilder.NOT_EQUALS;\n        this._config.filter[Symbol(alias)]={field,value,type};\n        return this;\n    }\n\n    higher(field, value, alias = field) {\n        const type = DAOQueryBuilder.HIGHER;\n        this._config.filter[Symbol(alias)] = { field, value, type };\n        return this;\n    }\n\n    higherOrEquals(field, value, alias = field) {\n        const type = DAOQueryBuilder.HIGHEROREQUALS;\n        this._config.filter[Symbol(alias)] = { field, value, type };\n        return this;\n    }\n\n    lower(field, value, alias = field) {\n        const type = DAOQueryBuilder.LOWER;\n        this._config.filter[Symbol(alias)] = { field, value, type };\n        return this;\n    }\n\n    lowerOrEquals(field, value, alias = field) {\n        const type = DAOQueryBuilder.LOWEROREQUALS;\n        this._config.filter[Symbol(alias)] = { field, value, type };\n        return this;\n    }\n\n    orderBy(field, direction = 'asc', alias = field) {\n        this._config.order.push({ alias, field, direction });\n        return this;\n    }\n\n    includes(field, value, alias = field) {\n        const type = DAOQueryBuilder.INCLUDES;\n        this._config.filter[Symbol(alias)] = { field, value, type };\n        return this;\n    }\n\n    starts(field, value, alias = field) {\n        const type = DAOQueryBuilder.STARTS;\n        this._config.filter[Symbol(alias)] = { field, value, type };\n        return this;\n    }\n\n    ends(field, value, alias = field) {\n        const type = DAOQueryBuilder.ENDS;\n        this._config.filter[Symbol(alias)] = { field, value, type };\n        return this;\n    }\n\n    limit(from = 0, to = -1) {\n        this._config.limit = { from, to };\n        return this;\n    }\n\n    groupStart(){\n        this.group++;\n        this.groupActive++;\n        const type = DAOQueryBuilder.GROUP_START;\n        this._config.filter[Symbol('group_start')] = {field:'group_start',value:'group_start',type};\n        return this;\n    }\n\n    groupEnd(){\n        this.group--;\n        this.groupActive--;\n        const type = DAOQueryBuilder.GROUP_END;\n        this._config.filter[Symbol('group_end')] = {field:'group_end',value:'group_end',type};\n        return this;\n    }\n\n    and() {\n        const type = DAOQueryBuilder.AND;\n        this._config.filter[Symbol('and')] = {field:'and',value:'and',type};\n        return this;\n    }\n\n    or() {\n        const type = DAOQueryBuilder.OR;\n        this._config.filter[Symbol('or')] = {field:'or',value:'or',type};\n        return this;\n    }\n\n    async run(name) {\n        if (this.group!==0) throw Error('Unbalanced selections');\n        return this.dao.find(this.config, name);\n    }\n\n}\n\nDAOQueryBuilder.OR = Symbol('or');\nDAOQueryBuilder.AND = Symbol('and');\nDAOQueryBuilder.GROUP_START = Symbol('group_start');\nDAOQueryBuilder.GROUP_END = Symbol('group_end');\nDAOQueryBuilder.NOT_EQUALS = Symbol('not_equals');\n\nDAOQueryBuilder.RANGE = Symbol('range');\nDAOQueryBuilder.EQUALS = Symbol('equals');\nDAOQueryBuilder.LOWER = Symbol('lower');\nDAOQueryBuilder.LOWEROREQUALS = Symbol('lowerorequals');\nDAOQueryBuilder.HIGHER = Symbol('higher');\nDAOQueryBuilder.HIGHEROREQUALS = Symbol('higherorequals');\nDAOQueryBuilder.INCLUDES = Symbol('includes');\nDAOQueryBuilder.STARTS = Symbol('starts');\nDAOQueryBuilder.ENDS = Symbol('ends');\n","import {DAOCommand} from \"./DAOCommand\";\nimport {StoreStrategy} from \"./StoreStrategy\";\nimport {DAOQueryBuilder} from \"./DAOQueryBuilder\";\n\n/**\n *\n */\nexport class DAO {\n\n    constructor(name,pk) {\n        this.name = name;\n        this.pk = pk;\n        this.resultsetCommands = {};\n        this.workers = 0;\n        this.errors = {};\n    }\n    /**\n     *\n     * @param command\n     * @returns {Promise<void>}\n     */\n    async execute(command) {\n        this.workers++;\n        //We delete the error for that command.\n        delete this.errors[command.name];\n        if (command.isResultset()) {\n            this.resultsetCommands[command.name]=command;\n        }\n        command.commandHasStarted();\n    };\n    /**\n     * Query builder.\n     * @returns {{}}\n     */\n    query() {\n        return new DAOQueryBuilder(this);\n    }\n    /**\n     *\n     * @param parameter\n     * @param options\n     * @param name\n     * @returns {Promise<void>}\n     */\n    async find(parameter,name=DAO.DEFAULT_RESULTSET) {\n        const command = this.createCommand(parameter, {save: false, remove: false}, this, name);\n        return this.execute(command).then((data)=>{\n                                             this.done(command,data);\n                                             return data;\n                                         }).catch((e)=>{\n                                             this.failed(command,e);\n                                         });\n    }\n    /**\n     *\n     * @param options\n     * @param name\n     * @returns {Promise<*>}\n     */\n    async findAll(options=null,name=DAO.DEFAULT_RESULTSET) {\n        return this.find(this.query().config,name);\n    }\n    /**\n     *\n     * @param data\n     * @returns {Promise<void>}\n     */\n    async save(data) {\n        const command = this.createCommand(data,{save:true,remove:false},this);\n        return this.execute(command)\n            .then((data)=>{\n                this.done(command,data);\n                return data;\n            })\n            .catch((e)=>{\n                this.failed(command,e);\n                throw new Error(e);\n            });\n    }\n    /**\n     * Cleans the errors.\n     * @param name\n     */\n    resetErrors(name) {\n        if (!name) {\n            this.errors = {};\n        } else {\n            delete this.errors[name];\n        }\n    }\n    /**\n     * Cleans the Resultsets binded commands\n     * @param name\n     */\n    clean(name=DAO.DEFAULT_RESULTSET) {\n        delete this.resultsetCommands[name];\n    }\n    /**\n     *\n     * @param data\n     * @returns {Promise<void>}\n     */\n    async remove(data) {\n        const command = this.createCommand(data,{save:false,remove:true},this);\n        return this.execute(command)\n            .then((data)=>{\n                this.done(command,data);\n                return data;\n            })\n            .catch((e)=>{\n                throw new Error(e);\n            });\n    }\n    /**\n     *\n     * @param id\n     * @param options\n     * @param name\n     * @returns {Promise<*>}\n     */\n    async findByPk(id,options=null,name=DAO.DEFAULT_RESULTSET) {\n        const filter = {};\n        const query = new DAOQueryBuilder(this);\n        query.equals(this.pk,id);\n        return this.find(query.config,name);\n    }\n    /**\n     *\n     * @param parameter\n     * @param operation\n     * @param target\n     * @param options\n     * @param name\n     * @returns {DAOCommand}\n     */\n    createCommand(parameter,operation,target,name) {\n        return new DAOCommand(parameter,operation,target,name);\n    }\n    /*8\n\n     */\n    done(command,data) {\n        this.workers--;\n        command.done(data);\n        if (command.isSave()||command.isRemove()) this.strategy.notify();\n    }\n    /**\n     *\n     */\n    failed(command,error) {\n        this.workers--;\n        this.errors[command.name]=error;\n        error[command.name]=error;\n        command.failed(error);\n    }\n    /**\n     *\n     * @returns {*}\n     */\n    getResultsets() {\n        const keys = Object.keys(this.resultsetCommands);\n        //If only have onw resultset we return the default.\n        if (keys.length===1) {\n            return this.resultsetCommands[DAO.DEFAULT_RESULTSET].data;\n        } else   if (keys.length===0) {\n            return [];\n        } else {\n            return new Proxy(this.resultsetCommands,{\n                get(target,propKey) {\n                    return target[propKey].data;\n                }\n            });\n        }\n    }\n    /**\n     *\n     */\n    refresh() {\n        Object.keys(this.resultsetCommands).forEach( (k)=>{\n            try {\n                const command = this.resultsetCommands[k];\n                this.execute(command).then((data)=>{\n                    this.done(command,data);\n                }).catch((e)=>{\n                    this.failed(command,e);\n                })\n            } catch (e) {\n                console.log('FALLLLEEEEEEEEE')\n            }\n\n        });\n    }\n}\n\nDAO.DEFAULT_RESULTSET = '_default';\n","import _ from 'lodash';\n\n\nclass DatabaseRAW {\n\n    constructor() {\n        this.daos = {};\n        this._sessions = {};\n    }\n\n    register(strategy,dao=null) {\n        //If DAO is not specified it will create the default DAO of the Store.\n        if (!dao) dao=strategy.createDAO();\n        this.daos[strategy.name] = {\n            dao,strategy\n        };\n    }\n\n    get(name) {\n        return this.daos[name];\n    }\n\n    get sessions() {\n        return this._sessions;\n    }\n\n    get listSessions() {\n        return _.toArray(this._sessions);\n    }\n\n    addSessionStrategy(strategy) {\n        this.sessions[strategy.name] = strategy;\n        strategy.recoverSession();\n    }\n\n    getSessionStrategy(name) {\n        return this.sessions[name];\n    }\n\n\n}\nexport const Database = new DatabaseRAW();","import React from 'react';\nimport {Database} from \"./Database\";\nimport {DAOCommand} from \"./DAOCommand\";\n\nexport function DatabaseConnector(WrappedComponent, selectData) {\n\n    return (...daos)=> {\n\n        return class extends React.Component {\n\n            constructor(props) {\n                super(props);\n                const me = this;\n                this.state = {\n                    libby : new Proxy({},{\n                        findErrors() {\n                            const errors=[];\n                            Object.keys(me.state.libby).forEach((name)=>{\n                                const dao = me.state.libby[name];\n                                //FIXME We should evalute differently the DAOs\n                                if (dao.name) {\n                                    if (Object.keys(dao.errors).length>0) errors.push(...Object.values(dao.errors));\n                                }\n                            });\n                            return errors;\n                        },\n                        workingSession() {\n                            let working = 0;\n                                Database.listSessions.forEach((session)=>{\n                                    working += session.working;\n                                });\n                            return working;\n                        },\n                        workingDAO() {\n                            let working = 0;\n                            if (me.state)\n                                Object.keys(me.state.libby).forEach((name)=>{\n                                    const dao = me.state.libby[name];\n                                    //FIXME We should evalute differently the DAOs\n                                    if (dao.name) {\n                                        working += dao.workers;\n                                    }\n                                });\n                            return working;\n                        },\n                        get(target,propKey) {\n                            //TODO ADD ERRORS COMMING FROM DAOs, and FLAG hasErrors\n                            //TODO ADD findAll && findByPk && find as a shortcut to all DAOs\n                            //TODO ADD SUPPORT FOR SAVE && REMOVE when only has one DAO\n                            switch (propKey) {\n                                 case 'workingDAO':\n                                  return this.workingDAO()>0;\n                                 case 'workingSession':\n                                  return (this.workingSession()>0);\n                                 case 'working':\n                                    return ((this.workingSession()+this.workingDAO())>0);\n                                case 'hasErrors':\n                                    return this.findErrors().length>0;\n                                case \"errors\":\n                                    return this.findErrors();\n                                 case \"session\":\n                                     /**\n                                      * When you ask for the session will return a Proxy\n                                      * To all sessions, if there is only one it will\n                                      * proxy again the object and return a proxy to that\n                                      * specific version just in case that you want to call\n                                      * the session by name.\n                                      *\n                                      *  ie: libby.session.firestore === libby.session When only one session present\n                                      *\n                                      *  This is because of the dual proxy, the only restriction on this\n                                      *  is calling a strategy with the same name of a native method.\n                                      */\n                                     return new Proxy({},{\n                                         set(target,propkey,value) {\n                                             const keys = Object.keys(Database.sessions);\n                                             //If only has one Session try to connect directly\n                                             if (keys.length === 1) {\n                                                 const active = Database.sessions[keys[0]];\n                                                 if (Reflect.has(active,propkey)) {\n                                                     return Reflect.set(active,propkey,value);\n                                                 }\n                                             }\n                                             return Reflect.set(Database.sessions,propkey,value);\n                                         },\n                                         get(target,propkey) {\n                                             const keys = Object.keys(Database.sessions);\n                                             //If only has one Session try to connect directly\n                                             if (keys.length === 1) {\n                                                 const active = Database.sessions[keys[0]];\n                                                 if (Reflect.has(active,propkey)) {\n                                                     return active[propkey];\n                                                 }\n                                             }\n                                             return Database.sessions[propkey];\n                                         }\n                                     });\n\n                            }\n                            return Reflect.get(target,propKey);\n                        }\n                    })\n                };\n                //We push all the DAOs to the libby connector.\n                daos.forEach((name)=>{\n                    //We obtain the DAO class\n                    const Dao = Database.get(name).dao;\n                    const target = new Dao();\n                    //We overload the createCommand method so the DAO can determine who is the target of the command.\n                    target.createCommand=(data,operation,target,name)=>{\n                        return new DAOCommand(data,operation,this,name);\n                    };\n                    //We create a proxy tu access to the command data directly\n                    this.state.libby[name]=new Proxy(target, {\n                        get(target, propKey) {\n                            if (propKey==='data') {\n                                return target.getResultsets();\n                            }\n                            return Reflect.get(target,propKey);\n                        }\n                    });\n                });\n\n            };\n\n            componentWillMount() {\n                //TODO BIND FOR REMOTE UPDATES\n                daos.forEach((name)=>{\n                    const cfg = Database.get(name);\n                    cfg.strategy.addStoreListener(this);\n                });\n                //Bind sessions updates\n                Object.keys(Database.sessions).forEach((name)=>{\n                    const cfg = Database.sessions[name];\n                    cfg.addSessionListener(this);\n                });\n            };\n\n            componentWillUnmount() {\n                //TODO UNBIND OF REMOTE UPDATES\n                daos.forEach((name)=>{\n                    const cfg = Database.get(name);\n                    cfg.strategy.removeStoreListener(this);\n                });\n                //Unbind session updates\n                Object.keys(Database.sessions).forEach((name)=>{\n                    const cfg = Database.sessions[name];\n                    cfg.removeSessionListener(this);\n                });\n            };\n\n            /**\n             * newSessionState\n             */\n            newSessionState(state,source) {\n                //TODO ADD CALLBACK TO THE CLIENT TO TRIGGER SESSION CHANGES\n                this.state.libby.sessionChanged=true;\n                this.setState({libby:this.state.libby})\n            }\n            /**\n             * This will be triggered when one or more stores asociated with the DAO has changed.\n             * @param name\n             */\n            storeHasChanged(name) {\n                //TODO ALOW TO THE FINAL USER TO DECIDE IF THE DAO HAS TO REFRESH\n                const dao = this.state.libby[name];\n                dao.refresh();\n            }\n            /**\n             * When when command has started\n             */\n            stateHasChanged() {\n                this.forceUpdate();\n            }\n            /**\n             * When one of the command has ended\n             * @param name\n             * @param resultset\n             */\n            propagateDAO(name,resultset) {\n                this.state.libby.sessionChanged=false;\n                this.setState({libby:this.state.libby});\n            }\n\n            render() {\n                // ... and renders the wrapped component with the fresh data!\n                // Notice that we pass through any additional props\n                return <WrappedComponent libby={this.state.libby}  {...this.props} />\n            }\n        };\n    }\n}\n","import {DAO} from \"../DAO\";\nimport {Database} from \"../Database\";\nimport _ from \"lodash\";\n\n/**\n * MemoryDAO Uses the MemorySrategy to keep the in memory database\n */\nexport class MemoryDAO extends DAO {\n\n    constructor(name,pk) {\n        super(name,pk);\n        this.strategy = Database.get(name).strategy;\n    }\n    /**\n     * Processes the resultsets commands\n     * @param command\n     * @returns {Promise<void>}\n     */\n    async processResultset(command) {\n        return this.strategy.find(command.parameter,);\n    }\n    /**\n     * Processes the insert/update commands\n     * @param command\n     * @returns {Promise<*|Promise<*>|void>}\n     */\n    async processChange(command) {\n        return this.strategy.save(command.parameter)\n            .then((saved)=>{\n                return saved;\n            })\n    }\n    /**\n     * Processes the insert/update commands\n     * @param command\n     * @returns {Promise<*|Promise<*>|void>}\n     */\n    async processRemove(command) {\n        return this.strategy.remove(command.parameter)\n            .then((removed)=>{\n                return removed;\n            })\n    }\n    /**\n     * Executes the received commands\n     * @param command\n     * @returns {Promise<void>}\n     */\n    async execute(command) {\n        //Always exeute the parent in order to kept the platforma healtrh\n        super.execute(command);\n        if (!command.isSave()) {\n            if (command.isRemove()) {\n                return this.processRemove(command);\n            }\n            return this.processResultset(command);\n        } else {\n            return this.processChange(command);\n        }\n\n    }\n\n\n\n\n}","import _ from 'lodash';\nimport {StoreStrategy} from \"../StoreStrategy\";\nimport {DAOQueryBuilder} from \"../DAOQueryBuilder\";\nimport {MemoryDAO} from \"./MemoryDAO\";\n\n/**\n * Metalanguage conditions\n * @type {{}}\n */\n//FIXME We should add the optional for matching insensitive actions\nconst JSConditions = {};\nJSConditions[DAOQueryBuilder.RANGE]=(data,value,to)=>{return data>=value&&data<=to};\nJSConditions[DAOQueryBuilder.LOWEROREQUALS]=(data,value)=>{return data<=value};\nJSConditions[DAOQueryBuilder.LOWER]=(data,value)=>{return data<value};\nJSConditions[DAOQueryBuilder.EQUALS]=(data,value)=>{return data===value};\nJSConditions[DAOQueryBuilder.HIGHEROREQUALS]=(data,value)=>{return data>=value};\nJSConditions[DAOQueryBuilder.HIGHER]=(data,value)=>{return data>value};\nJSConditions[DAOQueryBuilder.INCLUDES]=(data,value)=>{return data.includes(value)};\nJSConditions[DAOQueryBuilder.STARTS]=(data,value)=>{return data.startsWith(value)};\nJSConditions[DAOQueryBuilder.ENDS]=(data,value)=>{return data.endsWith(value)};\n/**\n *\n */\nconst Comparator= {\n    asc:(property)=>(x, y) => {\n    if (x[property] === y[property]) {\n        return 0;\n    }\n    return x[property] > y[property] ? 1 : -1;\n    },\n    desc:(property)=>(x, y) => {\n        if (x[property] === y[property]) {\n            return 0;\n        }\n        return x[property] < y[property] ? 1 : -1;\n    }\n}\n/**\n * Handle a memory database.\n * TODO We should add suppport for references so the Storage will automaticaly search for other objects\n */\nexport class MemoryStoreStrategy extends StoreStrategy {\n    /**\n     * Initialize the MemoryStrategy\n     * TODO We should add support for localstorage to avoid initializing\n     * @param name\n     * @param pk\n     * @param initialData\n     */\n    constructor(name,pk,initialData = []) {\n        super(name,pk);\n        this.setList(initialData);\n    }\n    /**\n     *\n     * @param parameter\n     */\n    async find(parameter) {\n    try {\n        if (Object.keys(parameter).length === 0) {\n            return this.list;\n        }\n        const {list} = this;\n        const {order,limit} = parameter;\n        let data = [];\n        //Filter conditions over data\n        for (let i = 0; i < list.length; i++) {\n            const item = list[i];\n            if (this.evaluate(item, parameter)) data.push(item);\n        }\n        //If limit applies the filter array\n        if (limit.from>0&&data.length>0) {\n            if (limit.to===-1) {\n                //Defines a range, where the elements must be.\n                data = data.slice(0, Math.min(data.length,limit.from));\n            } else {\n                //Just limits the sice of the element ion the array\n                data = data.slice(limit.from-1, Math.max(data.length,limit.to));\n            }\n        }\n        //FIXME We should fix the comparator to make the comparision on all the fields on same time, to emulate the SQL OrderBy\n        //Sorts by the key specified\n        for (let i = 0; i < order.length; i++) {\n            const cond = order[i];\n            data=data.sort(Comparator[cond.direction](cond.field));\n        }\n        return data;\n    } catch (e) {\n        throw new Error(e);\n    }\n    }\n\n    /**\n     * Since the Query builder does not support OR it will AND all the conditions.\n     */\n    evaluate(item,query) {\n        const {filter} = query;\n        const all = Object.keys(filter);\n        for (let i=0;i<all.length;i++) {\n            const condition = filter[all[i]];\n            const data = item[condition.field];\n            if (!JSConditions[condition.type](data,condition.value,condition.to)) return false;\n        }\n        return true;\n    }\n\n    /**\n     * In order to avoid objet changes we clone the data so it can not be modified by the DAOs\n     * We should proxy the data or seal the objects, it will seriously increase the speed.\n     * @returns {*}\n     */\n    get list() {\n        return _.cloneDeep(this._list);\n    };\n    /**\n     * Generates a GUID string.\n     * @returns {String} The generated GUID.\n     * @example af8a8416-6e18-a307-bd9c-f2c947bbb3aa\n     * @author Slavik Meltser (slavik@meltser.info).\n     * @link http://slavik.meltser.info/?p=142\n     */\n    guid() {\n        function _p8(s) {\n            const p = (Math.random().toString(16)+\"000000000\").substr(2,8);\n            return s ? \"-\" + p.substr(0,4) + \"-\" + p.substr(4,4) : p ;\n        }\n        return _p8() + _p8(true) + _p8(true) + _p8();\n    }\n    /**\n     * Bulks all the data to the memory\n     * @param list\n     */\n    setList(list) {\n        this.map={};\n        this._list=[];\n        list.forEach((raw)=>{\n            const o = _.cloneDeep(raw);\n            this._list.push(raw);\n            this.map[o[this.pk]]=o;\n        });\n    }\n\n    /**\n     *\n     * @param raw\n     * @returns {Promise<void>}\n     */\n    async remove(raw) {\n        const list = this.list;\n        _.remove(list,(e)=>e[this.pk]===raw[this.pk]);\n        this.setList(list);\n        return raw;\n    }\n    /**\n     * Stores on the memory the data depending if it is an update or an insert.\n     * @param raw\n     */\n    async save(raw) {\n        try {\n            const ob = _.cloneDeep(raw);\n            if (ob[this.pk]) {\n                this.map[ob[this.pk]] = ob;\n                _.remove(this._list, (o) => o[this.pk] === ob[this.pk]);\n                this._list.push(ob);\n            } else {\n                ob[this.pk] = this.guid();\n                this.map[ob[this.pk]] = ob;\n                this._list.push(ob);\n            }\n            return _.cloneDeep(ob);\n        } catch (e) {\n            console.error(e);\n        }\n    }\n\n    createDAO() {\n        const me = this;\n        return class extends MemoryDAO {\n            constructor() {\n                super(me.name,me.pk);\n            }\n        };\n    }\n\n\n}","\n\nexport class SessionStore {\n\n    \n\n    async perisist(token) {\n\n    }\n\n    clean() {\n\n    }\n\n    async retrieve() {\n        return null;\n    }\n\n}","import _ from \"lodash\";\n\nexport class Mapper {\n\n    constructor(mapper,fallback=(name,source)=>null) {\n        this.mapper = mapper;\n        this.fallback = fallback;\n        this.extramapper = [];\n    }\n\n    addAttribute(name,mapper,child) {\n        this.extramapper.push({name,mapper,child});\n        return this;\n    }\n    mapField(source,name) {\n        const mapped = _.get(this.mapper,name);\n        let value = null;\n        if (_.isString(mapped)) {\n            value = _.get(source,mapped);\n        }\n        if (value===undefined||value===null) {\n            value = this.fallback(name,source);\n        }\n        return value;\n    }\n    map(Type,source,attributes) {\n        const target = {};\n        attributes.concat(this.extramapper).forEach((attribute)=>{\n            if (typeof(attribute)==='string') {\n                target[attribute]=this.mapField(source, attribute)\n            } else {\n                target[attribute.name]=attribute.mapper.map(source[attribute.child]);\n            }\n        });\n        return new Type(target,source);\n    }\n\n\n}","export class RoleDTO {\n\n    constructor(nativerole,original) {\n        this._nativerole = nativerole;\n        this.nativerole = original;\n    }\n\n    get id() {\n        return this._nativerole.id;\n    }\n    get name() {\n       return this._nativerole.name;\n    }\n\n    get native() {\n        return this._nativerole;\n    }\n\n    hasPermissions(target) {\n        return false;\n    }\n\n\n}","import _ from \"lodash\";\nimport {Mapper} from \"./Mapper\";\nimport {RoleDTO} from '../RoleDTO'\nconst attributes = ['id','name'];\n\nexport class RoleMapper  extends Mapper{\n\n    constructor(mapper,fallback) {\n        super(mapper,fallback);\n    }\n\n    map(source) {\n       return super.map(RoleDTO,source,attributes)\n    }\n\n    static create(mapper,fallback) {\n        return new RoleMapper(mapper,fallback);\n    }\n\n}","import {RoleDTO} from \"./RoleDTO\";\n\nexport class UserDTO {\n\n    constructor(nativeuser,originaluser) {\n        this._nativeuser = nativeuser;\n        this.originaluser = originaluser;\n    }\n\n    get id() {\n        return this._nativeuser.id;\n    }\n    get native() {\n        return this._nativeuser;\n    }\n\n    get original() {\n        return this.originaluser;\n    }\n\n    get friendlyName() {\n        return `${this.name} ${this.lastname}`;\n    }\n\n    get name() {\n        return this.native.name;\n    }\n\n    get lastname() {\n        return this.native.lastname;\n    }\n\n    isGuest() {\n        return this._nativeuser.isGuest;\n    }\n\n    get username() {\n        return this._nativeuser.username;\n    }\n\n    get role() {\n        return new RoleDTO(this._nativeuser.role);\n    }\n\n}\n\nexport class GuestUser extends UserDTO {\n\n    constructor() {\n        super({isGuest:true,username:'guest',name:'guest',lastname:'',role:{name:'guest'}});\n    }\n\n}","import {UserDTO} from \"../UserDTO\";\nimport {Mapper} from \"./Mapper\";\n\nconst attributes = ['isGuest','username','name','lastname','id'];\n\nexport class UserMapper extends Mapper {\n\n    constructor(mapper,fallback) {\n        super(mapper,fallback);\n    }\n\n    map(source) {\n        return super.map(UserDTO,source,attributes)\n    }\n\n    /**\n     *\n     * @param mapper Mapper for the User\n     * @param rolemapper Mapper for the Role\n     * @param child Object that represents the role.\n     * @param fallback Fallback for the attributes\n     * @returns {*}\n     */\n    static create(mapper,rolemapper,child,fallback) {\n        return (new UserMapper(mapper,fallback)).addAttribute('role',rolemapper,child);\n    }\n\n\n}","import _ from \"lodash\";\nimport {GuestUser} from \"./user/UserDTO\";\nimport {SessionStore} from \"./session/storage/SessionStore\";\n\n/**\n *\n */\nexport class SessionStrategy {\n\n    constructor(props) {\n        this.listeners = [];\n        this.working = 0;\n        this._tokenmanager = new SessionStore();\n        this._user = SessionStrategy.GUEST_USER;\n        this.userMapper = null;\n        this.lastMessage = null;\n    };\n\n\n    setUserMapper(mapper,guestuser) {\n        this.userMapper = mapper;\n        SessionStrategy.GUEST_USER = guestuser;\n    }\n    set user(native) {\n        try {\n            if (this.userMapper) {\n                this._user = this.userMapper.map(native);\n            } else {\n                this._user = native;\n            }\n        } catch (e) {\n            console.error(e);\n        }\n    }\n\n    get user() {\n        return this._user;\n    }\n\n    acceptSession(user=this._user) {\n        this.startWorking();\n        this.notify(SessionStrategy.LOGGED,user);\n    }\n\n    recoverSession() {\n        this.startWorking();\n    }\n\n    getLastMessage() {\n        return this.lastMessage;\n    }\n    isLogged() {\n        return (this.state === SessionStrategy.NEW_SESSION && this.user.isGuest()===false)||(this.state === SessionStrategy.LOGGED);\n    }\n\n    init() {\n        this.startWorking();\n    }\n\n    get state() {\n        return this._state || SessionStrategy.NO_SESSION;\n    }\n    set state(state) {\n        this._state = state;\n    }\n    /**\n     *\n     * @returns {string}\n     */\n    get name() {\n        return \"SessionStrategy\";\n    }\n    startWorking() {\n        this.working++;\n        this.listeners.forEach((listener) => {\n            listener.newSessionState(SessionStrategy.WORKING, this.name);\n        });\n    }\n\n    /**\n     *\n     * @param token\n     */\n    status(token) {\n\n    }\n    /**\n     *\n     * @param user\n     * @param pass\n     * @returns {Promise<void>}\n     */\n    async login(user,pass) {\n        this.startWorking();\n    }\n    /**\n     *\n     * @returns {Promise<void>}\n     */\n    async logout() {\n        this.startWorking();\n    }\n    /**\n     *\n     * @param listener\n     */\n    addSessionListener(listener) {\n        this.listeners.push(listener);\n    }\n    /**\n     *\n     * @param listener\n     */\n    removeSessionListener(listener) {\n        _.pull(this.listeners,listener);\n    }\n    /**\n     *\n     * @param state Current state\n     * @param user Active user in the operation\n     */\n    notify(state,user=SessionStrategy.GUEST_USER,token,message=\"\") {\n        try {\n            if (state===SessionStrategy.NEW_SESSION) {\n                this.getTokenManager().persist(token);\n            }\n            this.lastMessage = message;\n            this.working--;\n            this.state = state;\n            this.user = user;\n            this.listeners.forEach((listener) => {\n                listener.newSessionState(state, this.name);\n            });\n        } catch (e) {\n            this.working--;\n            console.error(e);\n        }\n    };\n\n    /**\n     *\n     */\n    getTokenManager() {\n        return this._tokenmanager;\n    }\n    /**\n     *\n     * @param tkm\n     */\n    setTokenManager(tkm) {\n        this._tokenmanager = tkm;\n        return this;\n    }\n    /**\n     *\n     */\n    sessionHasExpired() {\n        this.startWorking();\n        this.notify(SessionStrategy.EXPIRED,this.user);\n    }\n\n};\n\nSessionStrategy.LOGGED = \"LOGGED\";\nSessionStrategy.NEW_SESSION = \"New session\";\nSessionStrategy.FAILED_TO_LOGIN = \"Failed to get session\";\nSessionStrategy.LOGOUT_SESSION = \"Logout session\";\nSessionStrategy.NO_SESSION = \"No session\";\nSessionStrategy.GUEST_USER = new GuestUser();\nSessionStrategy.WORKING = \"Working\";\nSessionStrategy.EXPIRED = \"Expired\";","import React from \"react\";\n\n\nclass LibbyComponent extends React.Component {\n\n    constructor(props) {\n        super(props);\n    }\n\n    get libby() {\n        return this.props.libby;\n    }\n\n    get working() {\n        return this.props.working;\n    }\n\n\n    componentDidUpdate(prevProps, prevState, snapshot) {\n    }\n\n    componentDidMount() {\n        this.fetchData(this.libby);\n    }\n\n    /**\n     * Executes the loading screen\n     * @param libby\n     */\n    fetchData(libby) {\n    }\n    /*\n     * Foreces call the fetchdata again\n     */\n    reload() {\n        this.fetchData(this.libby);\n    }\n\n    /**\n     * Draws the libby screen\n     * @param libby\n     * @returns {*}\n     */\n    draw(libby) {\n        return <h1>Implement the method draw(libby) to render the screen</h1>\n    }\n    /**\n     * Traps the render screen\n     * @returns {*}\n     */\n    render() {\n        return this.draw(this.libby);\n    }\n\n};\n\n\nexport const Libby = {\n    Component:LibbyComponent,\n    App:'LibbyApp'\n};"],"names":["DAOCommand","parameter","operation","save","remove","target","name","error","data","this","isResultset","propagateDAO","forceUpdate","e","stateHasChanged","StoreStrategy","pk","listeners","listener","push","_","pull","forEach","storeHasChanged","_this","Aggregate","getQuery","selected","config","fields","aggregations","groups","functions","groupbys","parameters","isArray","field","fn","operator","group","as","Operator","COUNT","SUM","AVG","MIN","MAX","run","bind","DAOQueryBuilder","dao","aggregated","_aggregate","_config","filter","order","limit","from","to","groupActive","_aggregated","Error","aggregate","value","alias","type","RANGE","Symbol","EQUALS","NOT_EQUALS","HIGHER","HIGHEROREQUALS","LOWER","LOWEROREQUALS","direction","INCLUDES","STARTS","ENDS","GROUP_START","GROUP_END","AND","OR","find","DAO","resultsetCommands","workers","errors","command","commandHasStarted","DEFAULT_RESULTSET","createCommand","execute","then","done","catch","failed","query","_this2","_this3","id","equals","isSave","isRemove","strategy","notify","keys","Object","length","Proxy","get","propKey","k","_this4","console","log","Database","daos","_sessions","createDAO","sessions","recoverSession","toArray","DatabaseConnector","WrappedComponent","selectData","props","me","state","libby","findErrors","values","workingSession","working","listSessions","session","workingDAO","set","propkey","active","Reflect","has","Dao","getResultsets","addStoreListener","addSessionListener","removeStoreListener","removeSessionListener","source","sessionChanged","setState","refresh","resultset","React","Component","MemoryDAO","saved","removed","processRemove","processResultset","processChange","JSConditions","includes","startsWith","endsWith","Comparator","asc","property","x","y","desc","MemoryStoreStrategy","initialData","setList","list","i","item","evaluate","slice","Math","min","max","cond","sort","all","condition","_p8","s","p","random","toString","substr","map","_list","raw","o","cloneDeep","ob","guid","SessionStore","token","Mapper","mapper","fallback","extramapper","child","mapped","isString","Type","attributes","concat","attribute","mapField","RoleDTO","nativerole","original","_nativerole","RoleMapper","UserDTO","nativeuser","originaluser","_nativeuser","isGuest","lastname","native","username","role","GuestUser","UserMapper","rolemapper","addAttribute","SessionStrategy","_tokenmanager","_user","GUEST_USER","userMapper","lastMessage","guestuser","user","startWorking","LOGGED","NEW_SESSION","newSessionState","WORKING","pass","message","getTokenManager","persist","tkm","EXPIRED","_state","NO_SESSION","FAILED_TO_LOGIN","LOGOUT_SESSION","Libby","prevProps","prevState","snapshot","fetchData","draw","App"],"mappings":"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"}